두 단계 락킹 규약(Two-Phase Locking, 2PL)은 **트랜잭션이 데이터베이스에서 직렬 가능(serializable)** 하도록 보장하는 **동시성 제어 기법**입니다. 이름처럼 트랜잭션의 **락(lock)** 획득과 해제를 두 단계로 나누는 방식입니다.

---

## ✅ 두 단계 락킹 규약(2PL)이란?

트랜잭션이 락을 사용하는 과정에서 다음 두 단계를 따릅니다:

### 1️⃣ **확장 단계 (Growing Phase)**
- 트랜잭션이 **락을 획득할 수 있지만**, **락을 해제할 수는 없음**
- 이 단계에서 트랜잭션은 읽기/쓰기 위해 공유 락(shared lock), 배타 락(exclusive lock)을 요청함

### 2️⃣ **축소 단계 (Shrinking Phase)**
- 트랜잭션이 **락을 해제할 수 있지만**, **더 이상 새로운 락을 얻을 수 없음**
- 락 하나라도 해제한 순간부터는 새로운 데이터 접근 불가

> 📌 트랜잭션이 락을 걸다가 한 번이라도 락을 해제하면, 더 이상 새로운 락을 요청할 수 없습니다.

---

## 🔒 예시

예를 들어 트랜잭션 T1이 다음과 같은 순서로 실행될 때:

```
T1:
1. X에 대해 Shared Lock 얻기
2. X 읽기
3. Y에 대해 Exclusive Lock 얻기
4. Y 쓰기
5. X 락 해제
6. Y 락 해제
```

여기서 T1은 1~4까지가 **확장 단계**, 5~6은 **축소 단계**에 해당합니다.  
**락 해제를 시작한 후엔 추가로 락을 얻지 않으므로 2PL 규약을 만족**합니다.

---

## ✅ 왜 필요한가요?

- 트랜잭션 간의 **충돌 방지**
- **직렬 가능성(serializability)** 보장
- 동시성 제어에서의 **데이터 일관성 유지**

---

## ⚠️ 주의할 점

| 한계 | 설명 |
|------|------|
| 교착 상태(Deadlock) 발생 가능 | 트랜잭션들이 서로가 가진 락을 기다리면 데드락 발생 |
| 락 보유 시간 증가 | 트랜잭션이 종료되기 전까지 락을 유지하므로 자원 회수 지연 가능 |

이를 해결하기 위한 **변형된 2PL** 방식들도 존재합니다:

### 📌 엄격 2PL (Strict 2PL)
- **모든 배타 락을 트랜잭션 종료 시점까지 유지**
- Recoverability가 좋음

### 📌 강력 2PL (Strong 2PL)
- 모든 락(공유/배타)을 트랜잭션 종료 시점까지 유지

---

## 🔷 2단계 락킹(2PL)의 실제 DBMS 활용

### 1️⃣ 대표 DBMS와 2PL 적용 예

| DBMS | 동시성 제어 방식 | 2PL 적용 여부 |
|------|------------------|----------------|
| **MySQL (InnoDB)** | **Strict 2PL** + MVCC | ✅ Yes |
| **PostgreSQL** | MVCC 중심, 내부적으로 락 사용 | ⛔ 2PL 직접 X (MVCC 우선) |
| **Oracle DB** | MVCC + 락 (Serializable 시 2PL 유사 동작) | ⭕ 조건부 사용 |
| **SQL Server** | Lock-based isolation levels (Read committed 등) | ✅ Yes |
| **DB2** | Strict 2PL 기반 | ✅ Yes |

> 💡 **Strict 2PL**: 트랜잭션이 커밋되기 전까지 **락을 절대 해제하지 않는** 강력한 형태로, 실제 DBMS에서는 주로 이 형태를 채택합니다.

---

## 🔸 실제로 어떻게 쓰일까?

### 예: MySQL InnoDB에서의 트랜잭션 처리

```sql
START TRANSACTION;
SELECT * FROM accounts WHERE id = 1 FOR UPDATE;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;
```

이 쿼리는 다음과 같은 방식으로 처리됩니다:

1. `SELECT ... FOR UPDATE` → 해당 row에 대해 **exclusive lock(X락)** 획득
2. 이후 업데이트 → 동일한 락 사용
3. **커밋 전까지는 락 유지 (Strict 2PL)**
4. 커밋 시 모든 락 **한 번에 해제**

➡️ **락 획득 단계 → 해제 단계로 단방향 진행 (2단계)**  
➡️ **Strict 2PL** 로 **직렬 가능성 보장**

---

## 🔍 DBMS는 왜 Strict 2PL을 쓸까?

| 이유 | 설명 |
|------|------|
| ✅ 직렬 가능성 보장 | 락이 해제되기 전까지 변경 불가 |
| 🔒 교착 상태 감지 | Lock Wait Timeout / Deadlock Detection |
| ⛔ 성능 제한 | 높은 동시성에서 병목 가능성 있음 |
| 🤝 트랜잭션 신뢰성 ↑ | 확실한 동시성 보장 가능 |

---

## 📌 요약

| 항목 | 내용 |
|------|------|
| 실제 사용 여부 | 대부분의 DBMS에서 사용 (또는 유사하게 구현) |
| 사용 형태 | 주로 **Strict 2PL** (락 해제는 커밋 시점까지 금지) |
| 예시 DBMS | MySQL(InnoDB), SQL Server, DB2 등 |
| 예외 | PostgreSQL/Oracle은 MVCC 기반이지만, 일부 격리수준에서는 유사 동작 |
| 역할 | **직렬 가능성 보장**, **데이터 일관성 유지** |

---

원리와 예제를 같이 보면서 정리해봤는데, 특정 DBMS에 대한 동작이 궁금하다면 그 DB에 맞춰 더 자세히 설명해줄 수도 있어요!  
원하는 DB가 있다면 알려줘요 🙂