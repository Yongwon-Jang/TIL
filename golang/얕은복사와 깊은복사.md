## 1. 얕은 복사 (Shallow Copy)

### 특징
- 값 타입 필드: 복사됨 (독립적)
- 참조 타입 필드: 참조만 복사됨 (공유됨)
- 메모리: 일부 공유
- 성능: 빠름

### 예시 코드

```go
// 예시 1: 구조체 할당 (=)
type Person struct {
    Name string        // 값 타입
    Age  int           // 값 타입
    Tags []string      // 참조 타입 (슬라이스)
}

original := Person{
    Name: "Alice",
    Age:  30,
    Tags: []string{"dev", "golang"},
}

shallowCopy := original  // 얕은 복사

// 값 타입 필드는 독립적
shallowCopy.Name = "Bob"  // original.Name은 "Alice" 그대로

// 참조 타입 필드는 공유됨!
shallowCopy.Tags[0] = "designer"  // original.Tags도 변경됨!
```

```go
// 예시 2: 슬라이스 copy() 함수
original := []int{1, 2, 3}
copy1 := make([]int, len(original))
copy(copy1, original)  // 값 타입이므로 독립적

copy1[0] = 999  // original은 변경 안됨
```

```go
// 예시 3: 슬라이스의 슬라이스 (2차원)
original := [][]int{{1, 2}, {3, 4}}
copy1 := make([][]int, len(original))
copy(copy1, original)  // 얕은 복사: 내부 슬라이스는 공유됨

copy1[0][0] = 999  // original[0][0]도 999로 변경됨!
```

```go
// 예시 4: 맵(Map)
original := map[string][]int{"a": {1, 2, 3}}
copy1 := make(map[string][]int)
for k, v := range original {
    copy1[k] = v  // 얕은 복사: 슬라이스는 공유됨
}

copy1["a"][0] = 999  // original["a"][0]도 999로 변경됨!
```

## 2. 깊은 복사 (Deep Copy)

### 특징
- 모든 필드: 재귀적으로 복사됨
- 참조 타입: 새로 생성됨 (독립적)
- 메모리: 완전히 독립적
- 성능: 느림 (재귀적 복사)

### 예시 코드

```go
// 예시 1: 구조체 깊은 복사 (수동)
type Person struct {
    Name string
    Age  int
    Tags []string
}

original := Person{
    Name: "Alice",
    Tags: []string{"dev", "golang"},
}

// 깊은 복사: 슬라이스도 새로 생성
deepCopy := Person{
    Name: original.Name,
    Age:  original.Age,
    Tags: make([]string, len(original.Tags)),
}
copy(deepCopy.Tags, original.Tags)

deepCopy.Tags[0] = "manager"  // original.Tags는 변경 안됨!
```

```go
// 예시 2: 슬라이스의 슬라이스 깊은 복사
original := [][]int{{1, 2}, {3, 4}}

// 깊은 복사: 각 내부 슬라이스도 새로 생성
deepCopy := make([][]int, len(original))
for i := range original {
    deepCopy[i] = make([]int, len(original[i]))
    copy(deepCopy[i], original[i])
}

deepCopy[0][0] = 999  // original[0][0]은 변경 안됨!
```

```go
// 예시 3: 재귀적 깊은 복사 함수
type Node struct {
    Value int
    Children []*Node
}

func deepCopyNode(n *Node) *Node {
    if n == nil {
        return nil
    }
    
    copy := &Node{
        Value: n.Value,
        Children: make([]*Node, len(n.Children)),
    }
    
    for i, child := range n.Children {
        copy.Children[i] = deepCopyNode(child)  // 재귀적 복사
    }
    
    return copy
}
```

```go
// 예시 4: JSON을 이용한 깊은 복사
import "encoding/json"

original := Person{Name: "Alice", Tags: []string{"dev"}}

// JSON 직렬화/역직렬화를 통한 깊은 복사
jsonData, _ := json.Marshal(original)
var deepCopy Person
json.Unmarshal(jsonData, &deepCopy)

deepCopy.Tags[0] = "manager"  // original.Tags는 변경 안됨!
```

## 3. 비교 테이블

| 구분 | 얕은 복사 | 깊은 복사 |
|------|----------|----------|
| 값 타입 필드 | 복사됨 (독립적) | 복사됨 (독립적) |
| 참조 타입 필드 | 참조만 복사 (공유됨) | 새로 생성 (독립적) |
| 메모리 | 공유됨 | 독립적 |
| 성능 | 빠름 | 느림 |
| 메모리 사용량 | 적음 | 많음 |
| 사용 방법 | `=` 할당, `copy()` | 수동 복사, 재귀적 복사, JSON 직렬화 |

## 4. 실전 예시: ReplicationGroup 깊은 복사

```go
type ReplicationGroup struct {
    SOURCE ReplicationMdp
    TARGET ReplicationMdp
}

type ReplicationMdp struct {
    OBJECTS []ReplicationObject  // 슬라이스 필드
}

// 얕은 복사 (문제 있음)
shallowCopy := original
shallowCopy.SOURCE.OBJECTS[0].Path = "/modified"
// original.SOURCE.OBJECTS[0].Path도 변경됨!

// 깊은 복사 (올바름)
deepCopy := ReplicationGroup{
    SOURCE: ReplicationMdp{
        OBJECTS: make([]ReplicationObject, len(original.SOURCE.OBJECTS)),
    },
    TARGET: ReplicationMdp{
        OBJECTS: make([]ReplicationObject, len(original.TARGET.OBJECTS)),
    },
}

// 각 OBJECTS 복사
for i := range original.SOURCE.OBJECTS {
    deepCopy.SOURCE.OBJECTS[i] = ReplicationObject{
        Path: original.SOURCE.OBJECTS[i].Path,
        Exclusions: make([]string, len(original.SOURCE.OBJECTS[i].Exclusions)),
    }
    copy(deepCopy.SOURCE.OBJECTS[i].Exclusions, original.SOURCE.OBJECTS[i].Exclusions)
}
```

## 요약

- 얕은 복사: 빠르지만 참조 타입은 공유됨
- 깊은 복사: 느리지만 완전히 독립적
- 선택 기준: 참조 타입 필드가 있고 독립성이 필요하면 깊은 복사 사용

작성한 예시 파일(`shallow_vs_deep_copy.go`)을 실행하면 모든 예시를 확인할 수 있습니다.